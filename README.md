# JAVASCRIPT-PRACTICE

기본이 중요하다!!!!!!!!!!!!!!!!!!!!!!!!!!!

------------------------------------------

&nbsp;처음에는 자바스크립트와 HTML따위는 걍 대충 갖다 쓰면 될 줄 알았다. 물론 되긴 됐지만, 역시 아무나 할 수 있는 그런 것이었지,, 개발자라고 할 수 없었다.

    Git 공부를 위해 branch별로 챕터를 나눠서 진행하겠다리..
    또한, Markdown 공부를 겸하겠다..

<hr>

1. 데이터 타입과 연산자
   1. 모든 언어의 기본은 **데이터 타입**을 파악하는 것부터 시작한다.
      1. 기본타입
         1. Number, String, Boolean, undefined, null
      2. 참조타입
         1. Object
            1. Array
            2. Function
            3. 정규표현식(exp)
   2. ```var foo = { name: 'foo', age: 30, gender: 'male'}```에서 foo 변수는 객체 자체를 저장하는 것이 아닌 생성된 객체의 주소를 가르키는 것이다.(참조값을 가르킴)
   3. 자료의 기본형은 함수 내 인자로 넘길 때 복사한 값을 넘기지만, 객체 즉 참조형은 참조값(주소값)을 넘긴다. 그렇기 때문에 기존 기본형 변수는 변하지 않지만 참조값을 변경하면 객체의 값은 바뀐다.
   4. 객체의 부모는 여기서 ``프로토 타입`` 이라고 부른다. 모든 객체는 ``프로토 타입(숨겨진 프로퍼티)``를 갖고 있다.
   5. ``splice()``를 이용하면 배열을 동적으로 삭제할 수 있다. ``golang``의 ``slice``와 같군..
   6. ``==``는 비교하려는 타입이 다를 경우 변환 후 비교하지만, ``===``는 그대로 비교한다.<br/><br/>
2. 함수와 프로토타입 체이닝
   1. 함수 생성법
      1. 함수 선언문(function statment)
         1. 익명 함수(함수명이 없는 자바스크립트의 함수선언)
      2. 함수 표현식(function expression)
         1. 변수형 함수
            1. 실제로 자바스크립트 엔진에서 함수명으로 변수명으로 하여 만들어 준다. 함수명은 선택사항
            2. ***함수선언 뒤에는 ``;``를 붙여주자!!!***
      3. Function() 생성자 함수  
         1. ``new Function(arg1, arg2, argN, functionBody)`` ``argN``은 매개변수, ``functionBody``는 실행된 코드를 포함한 문자열
   2. 하지만 ``함수 호이스팅``때문에 ``함수 표현식``만을 사용할 것을 권장하고 있다.
      1. 함수 호이스팅: 함수 선언문으로 정의된 함수는 scope가 코드의 맨 처음부터 끝이다.
   3. 함수도 **객체**다. 그러므로 함수 내에도 프로퍼티를 지정할 수 있다. 생성될 때 ``생성자``가 최초에 만들어진다.
   4. 함수를 인자로 전달 가능
   5. 함수의 다양한 형태
      1. 콜백함수와
      2. 즉시실행함수(최초 실행되는 초기화 코드에 사용)
      3. 내부함수
         1. 외부에서 접근할 수 없다. 내부함수에서 자신을 감싸고 있는 외부함수에는 접근 가능. 
            1. 하지만 내부함수의 리턴값을 호출해서 받으면 쌉가능
      4. 함수를 리턴하는 함수(자신을 호출해서 재정의가 가능하다)
      5. this바인딩을 쓰는 경우 내부함수 호출일지라도 전역변수를 호출하기 때문에 주의해야 한다.
   6. 자바스크립트 함수는 항상 **리턴값**을 반환한다.
      1. 리턴값을 지정하지 않는 경우, **undefined**값이 리턴된다.
   7. 자바스크립트의 ``OOP``를 이해하기 위해서는 ``Proto type``를 이해하는 것이 중요하다. 해당 ``proto type``의 ``property``에서 해당 메서드를 찾고 없으면 부모 격인 ``ProtoType``의 ``property``에서 매서드를 찾는다.
   8. 프로토타입도 자바스크립트의 객체다.. 그러므로 동적으로 할당이 가능하다.<br/><br/>
3. 실행 컨텍스트와 클로저
   1. 실행 컨텍스트
      1. 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념
      2. 실행 가능한 자바스크립트 코드 블록이 실행되는 환경
      3. 전역 실행 컨텍스트 -> 실행 컨텍스트
   2. 스코프 체인
   3. 클로저의 활용
      1. 특정 함수에 사용자가 정의한 객체의 메서드 연결하기
      2. 함수의 캡슐화
      3. setTimeout()에 지정되는 함수의 사용자 정의
   4. 클로저 사용 시 주의사항
      1. 프로퍼티값 쓰기가 가능하므로, 그 값이 여러 번 호출로 항상 변할 수 있음
      2. 하나의 클로저가 여러 함수 객체의 스코프 체인에 들어가 있는 경우도 있다.
      3. 루프 안에 클로저를 사용할 때는 주의하자
4. 객체지향 프로그래밍
   1. 다음과 같은 객체지향언어의 특성을 자바스크립트로 구현 가능하다.
      1. **클래스**, **생성자**, **메서드**
      2. **상속**
         1. 기능 추가
            1. 얇은 복사(shallow copy)
               1. 문자, 숫자 리터럴 등이 아닌 객체(함수, 배열 객체 포함)인 경우 해당 객체를 복사하지 않고, 참조한다.
            2. 깊은 복사(deep copy)
               1. 보통 extend함수를 통해 구현할 경우 대상이 객체일 때는 깊은 복사를 하는 것이 일반적이다.
               2. https://wanna-b.tistory.com/18 다음 글에서 해당 내용이 이해하기 쉽게 나와있다.
         2. 방법
            1. prototype 상속
            2. 클래스 기반 상속
               1. 부모 클래스의 인스턴스와 자식 클래스의 인스턴스를 독립적으로 두기 위해 ``중개자``를 만든다.
            3. 클래스의 기능을 가진 subClass 함수, 다음의 세가지를 이용하여 구현
               1. 함수의 프로토타입 체인
               2. extend 함수
               3. 인스턴스를 생성할 때 생성자 호출(여기서는 생성자를 _init함수로 정한다.)
      3. **캡슐화**
         1. ``OOP``에서 상당히 중요한 부분을 담당한다.
         2. 관련된 여러가지 정보를 하나의 틀 안에 담는 것이고 중요한 것은 정보의 **공개여부**이다.(``정보은닉``)
         3. **this객체의 프로퍼티는 외부에서 new로 생성한 객체로 접근할 수 있지만, var로 선언된 멤버들은 외부에서 접근이 불가능하다.**
            1. 하지만 퍼블릭 메서드를 통해 var로 선언된 멤버에 접근가능하다. 이것이 기본적인 자바스크립트의 ``정보은닉방법``이다.
      4. 끝내며,,,
         1. 아직은 이 단원의 ``subClass``항목이 언제, 어떻게 쓰이는지는 정확히 모르겠다. 기존의 상속방법을 쓰면 되는데 말이다.. 다음에 다시 다루도록 하자
5. 함수형 프로그래밍
   1. 여러가지 패러다임 중 하나이다.
   2. 함수의 조합으로 작업을 수행하는 것이며, 작업 동안에 작업에 필요한 데이터와 상태는 변하지 않는다.
      1. 순수함수(Pure function)
         1. 외부에 아무런 영향을 미치지 않는 함수
      2. 고계 함수(Higher-order function)
         1. 함수를 또 하나의 값으로 간주하여 함수의 인자 혹은 반환값으로 사용할 수 있는 함수
6. 기타
   1. BABEL
      1. ECMA Script의 최신 버전을 쓰고 배포할 때 이 전 버전으로 translate해주는 transcompiler
   2. DOM(Document Object Model)
      1. 웹개발의 3요소
         1. HTML
         2. CSS
         3. JavaScript
      2. 이 3개가 어떻게 웹 페이지에 보이는가를 생각해본다면 DOM의 역할을 유추해 볼 수 있다.
      3. DOM은 HTML, CSS, JS를 객체화하여 웹페이지에 보여줄 수 있는 interface다. 실제 DOM의 객체 구조를 보면 ``Document - HTML - head - title - Title Name`` 이런 식이다.
   3. Virtual DOM
      1. [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
      2. [React and the Virtual DOM](https://www.youtube.com/watch?v=BYbgopx44vo)
         1. 기존의 방식은 javascript 또는 jquery를 통해 수천가지의 노드 중에 변경 값을 찾기 위해 불필요한 연산이 많이 든다.
         2. 하지만 Virtual DOM은 DOM API를 직접 사용하지 않고, 메모리에 있는 domNode 객체를 활용하기 때문에 훨씬 더 빠르다.(객체의 key-value로 연결이 되어있기 때문에 ``O(1)``)
   4. 왜 우리는 더이상 ``jQuery``를 쓸 필요가 없는가?
      1. jQuery was great but jQuery is old! the web is different now
      2. What is jQuery
         1. AJAX
            1. XMLHttpRequest is standard(Fetch is bulit-in)
         2. DOM manipulation
         3. event handling
         4. animation
      3. Size가 너무 크다.(모듈화가 안되기 때문에 필요한 기능만 갖다 쓸 수 없다.)
      4. jQuery가 큰 호응을 얻었던 이유는 당시 브라우저 간(explorer, netscape 등) 호환이 안되는 ``Issue``가 있었기 때문에 개발된 API이기 때문이다.
         1. 지금은 ECMAScript5,6가 나오면서 호환이 가능
            1. BEBEL과 같은 transformation tools
            2. Vanilla JavaScript
            3. youmightnotneedjquery.com에 가보면 jquery의 많은 기능들을 대체할 수 있는 light function들이 있다.
      5. 하지만, jQuery는 여전히 사용하기 편하기 때문에 간단한 프로젝트에서 사용하면 좋다.
   5. ``Javascript``의 이벤트 루프에 관하여
      1. 함수를 실행하면 그 함수는 ``call stack``에 추가된다.
      2. 함수가 값을 반환하면 그 함수는 스택을 빠져나와 사라진다.
      3. 하지만, 그 함수가 반환하는 값이 ``setTimeout(() => {console.log('hi')}, 1000)``함수라면, 이 ``콜백함수``의 ``()=>{console.log('hi')}``가 ``Web API``에 추가되고, ``setTimeout``함수와 이를 반환한 함수는 스택에서 빠져나와 사라진다.
      4. ``Web API``안에서 타이머는 ``1000ms``동안 실행되며, 콜백은 즉시 호출 스택에 추가되지 않고, ``1000ms``후에 ``큐(대기열)``에 전달된다.
      5. ``콜 스택``이 비어있다면, ``큐``에 있는 첫 번째 요소가 ``콜 스택``에 추가된다.
      6. ``콜백함수``가 ``콜 스택``에 추가되고, 호출되고, 값을 반환하고 스택을 다시 빠져나간다.

